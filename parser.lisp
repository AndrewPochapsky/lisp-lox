(defpackage :parser
  (:use :common-lisp))

(in-package #:parser)

(defun parse (input)
  (labels ((helper (stmts input)
             (if (string= (symbol-name (lexer:token-type (car input))) "EOF")
                 (reverse stmts)
                 (let* ((result (decl input))
                        (stmt (first result))
                        (rest (second result)))
                   (helper (cons stmt stmts) rest)))))
    (helper '() input)))

(defun decl (input)
  (if (string= (symbol-name (lexer:token-type (car input))) "VAR")
      ; TODO: Consider adding 'synchronize' here.
      (var-declaration (cdr input))
      (statement input)))

(defun var-declaration (input)
  (let ((name (car input)))
    (if (string= (symbol-name (lexer:token-type name)) "IDENTIFIER")
        (if (string= (symbol-name (lexer:token-type (cadr input))) "EQUAL")
            (let* ((result (expression (cddr input)))
                   (initializer (first result))
                   (rest (second result)))
              (if (string= (symbol-name (lexer:token-type (car rest))) "SEMI-COLON")
                  (list (ast:make-variable-decl :name name :initializer initializer) (cdr rest))
                  (error "Expected ';' after variable declaration")))
            (if (string= (symbol-name (lexer:token-type (cdr input))) "SEMI-COLON")
              (list (ast:make-variable-decl :name name :initializer nil) (cddr input))
              (error "Expected ';' after variable declaration")))
        (error "Expected variable name"))))

(defun statement (input)
  (let ((token-type (lexer:token-type (car input))))
    (cond
      ((string= token-type 'print) (print-statement (cdr input)))
      ((string= token-type 'left-brace)
       (let* ((result (block-statement (cdr input)))
              (statements (first result))
              (rest (second result)))
         (list (ast:make-block-stmt :statements statements) rest)))
      (t (expression-statement input)))))

(defun print-statement (input)
  (let* ((result (expression input))
         (expr (first result))
         (rest (second result)))
    (if (string= (symbol-name (lexer:token-type (car rest))) "SEMI-COLON")
        (list (ast:make-print-stmt :expression expr) (cdr rest))
        (error "Expected ';' after value"))))

(defun expression-statement (input)
  (let* ((result (expression input))
         (expr (first result))
         (rest (second result)))
    (if (string= (symbol-name (lexer:token-type (car rest))) "SEMI-COLON")
        (list (ast:make-expression-stmt :expression expr) (cdr rest))
        (error "Expected ';' after expression"))))

(defun block-statement (input)
  (labels ((helper (statements input)
             (let ((token-type (lexer:token-type (car input))))
               (cond
                 ((string= token-type 'right-brace)
                  (list (reverse statements) (cdr input)))
                 ((string= token-type 'eof)
                  (error "Expected '}' after block"))
                 (t (let* ((result (decl input))
                           (value (first result))
                           (rest (second result)))
                      (helper (push value statements) rest)))))))
    (helper '() input)))


(defun expression (input)
  (assignment input))

(defun assignment (input)
  (let* ((result (equality input))
         (expr (first result))
         (rest (second result)))
    (if (string= (lexer:token-type (car rest)) 'equal)
        (let* ((result (assignment (cdr rest)))
               (value (first result))
               (rest (second result)))
          (if (ast:variable-ref-p expr)
              (list (ast:make-assign :name (ast:variable-ref-name expr) :expression value) rest)
              (error "Invalid assignment target")))
        (list expr rest))))

(defun equality (input)
  (let* ((result (comparison input))
         (expr (first result))
         (rest (second result)))
    (labels ((helper (expr input)
               (if (member (symbol-name (lexer:token-type (car input))) '("BANG-EQUAL" "EQUAL-EQUAL") :test #'string=)
                   (let* ((result (comparison (cdr input)))
                          (right (first result))
                          (rest (second result)))
                     (helper (ast:make-binary :left expr :operator (car input) :right right) rest))
                   (list expr input))))
      (helper expr rest))))

(defun comparison (input)
  (let* ((result (term input))
         (expr (first result))
         (rest (second result)))
    (labels ((helper (expr input)
               (let ((operator (car input)))
                 (if (member (symbol-name (lexer:token-type operator)) '("GREATER" "GREATER-EQUAL" "LESS" "LESS-EQUAL") :test #'string=)
                     (let* ((result (term (cdr input)))
                            (right (first result))
                            (rest (second result)))
                       (helper (ast:make-binary :left expr :operator operator :right right) rest))
                     (list expr input)))))
      (helper expr rest))))


(defun term (input)
    (let* ((result (factor input))
           (expr (first result))
           (rest (second result)))
      (labels ((helper (expr input)
                 (let ((operator (car input)))
                   (if (member (symbol-name (lexer:token-type operator)) '("MINUS" "PLUS") :test #'string=)
                       (let* ((result (factor (cdr input)))
                              (right (first result))
                              (rest (second result)))
                         (helper (ast:make-binary :left expr :operator operator :right right) rest))
                       (list expr input)))))
        (helper expr rest))))

(defun factor (input)
    (let* ((result (unary input))
           (expr (first result))
           (rest (second result)))
      (labels ((helper (expr input)
                 (let ((operator (car input)))
                   (if (member (symbol-name (lexer:token-type operator)) '("SLASH" "STAR") :test #'string=)
                       (let* ((result (unary (cdr input)))
                              (right (first result))
                              (rest (second result)))
                         (helper (ast:make-binary :left expr :operator operator :right right) rest))
                       (list expr input)))))
        (helper expr rest))))


(defun unary (input)
  (let ((operator (car input)))
    (if (member (symbol-name (lexer:token-type operator)) '("BANG" "MINUS") :test #'string=)
        (let* ((result (unary (cdr input)))
               (right (first result))
               (rest (second result)))
          (list (ast:make-unary :operator operator :right right) rest))
        (primary input))))

(defun primary (input)
  (let ((token-type (lexer:token-type (car input))))
    (cond
      ((string= token-type 'identifier) (list (ast:make-variable-ref :name (car input)) (cdr input)))
      ((string= token-type 'false) (list (ast:make-literal :value 'false) (cdr input)))
      ((string= token-type 'false) (list (ast:make-literal :value 'false) (cdr input)))
      ((string= token-type 'true) (list (ast:make-literal :value 'true) (cdr input)))
      ((string= token-type 'nil) (list (ast:make-literal :value nil) (cdr input)))
      ((string= token-type 'number) (list (ast:make-literal :value (lexer:token-lexeme (car input))) (cdr input)))
      ((string= token-type 'string) (list (ast:make-literal :value (lexer:token-lexeme (car input))) (cdr input)))
      ((string= token-type 'left-paren) (let* ((result (expression (cdr input)))
                                            (expr (first result))
                                            (rest (second result)))
                                       (if (string= (symbol-name (lexer:token-type (car rest))) "RIGHT-PAREN")
                                           (list (ast:make-grouping :expression expr) (cdr rest))
                                           (error "Expected ')' after expression."))))
      (t (error "Expected expression but got unexpected token ~a" (car input))))))

(let ((pack (find-package :parser)))
  (do-all-symbols (sym pack) (when (eql (symbol-package sym) pack) (export sym))))
